  + op code代表指令的类型，op code也决定寻址模式
  + 直接寻址、间接寻址和偏移量寻址，不要死记硬背，要理解。
  + 浮点数在计算机中是以整数形式存在的。

## 内存读写操作

  + load/store 指令用来从内存中读/写入内存，通常会有多个版本的实现，助记符是：
    - load类： lw, lb, lh
    - store类：sw, sb, sh

## 数学运算

  + **加减乘除等**
    - 立即寻址 addi, subi, divi, multi 等…
      * addi $sp, $sp, 4（把$sp加4后存入* $sp，相当于把%sp加4）
    - 寄存器寻址
		  * add %d, $rs, $rt
    - 也提供其他寻址方式

  + **位运算 and/or/xor 等**

  + **浮点小数**
    - 十进制里 0.1 代表 1/10，二进制里 0.1 代表 1/2，0.01 代表 1/4

  + **双精度浮点数表示**

    

![double](https://pic3.zhimg.com/80/v2-0faecd08386e94b0259056de48dcde9e_1440w.jpg, "示意图")

## 比较运算

  + 比较运算比较两个值的大小，例如：

	 - slt(set if less than)
		 * slt $d, $rs, $rt # 如果 rs<rt 则 d=1；如果rt>=rt 则 d=0

		  * slti $d, $rs, 5   # rs 和 5 比较，返回结果和上面一致

  + 另：汇编没有字符串比较、对象比较和布尔型比较的功能，都是转化为数字再进行比较的

## 条件跳转

  + 相对寻址
    - j LABEL # 跳转到LABEL（LABEL为相对的行号）

  + 寄存器间接寻址
    - jr $a0 # 跳转到 $a0 寄存器数值的位置

  + 多合一
    - jal LABEL # 也是跳转到 LABEL，但是会像函数一样跳
		  * 即：1. 将当前 PC+4 存入 $ra 寄存器 2. 再 j LABEL
    - 这样做有什么好处呢？就是执行完还想回来的话就用 j LABEL 跳回来即可
